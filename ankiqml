#!/usr/bin/python2.6

import sys, os
sys.path[0] = "/usr/share/ankiqml"

from PySide import QtCore
from PySide.QtGui import *
from PySide.QtCore import *
from PySide.QtDeclarative import QDeclarativeView
import anki
from anki.stdmodels import BasicModel

class DecksModel(QAbstractListModel):

    NameRole = Qt.UserRole + 1
    PathRole = Qt.UserRole + 2
    FactCountRole = Qt.UserRole + 3
    CardCountRole = Qt.UserRole + 4

    def __init__(self, parent = None):
        QAbstractListModel.__init__(self, parent)
        self.setRoleNames({
            DecksModel.NameRole : 'deckName',
            DecksModel.PathRole : 'deckPath',
            DecksModel.FactCountRole : 'deckFactCount',
            DecksModel.CardCountRole : 'deckCardCount',
            Qt.DisplayRole : 'display' 
            })
        self._data = []

    @QtCore.Slot(result=int)
    def getCount(self):
        return len(self._data)

    def rowCount(self, index):
        return len(self._data)

    @QtCore.Slot(int, str, str)
    def setData(self, index, role, value):
        self._data[index][role] = value
        self.emit(QtCore.SIGNAL("dataChanged()"))

    @QtCore.Slot(int, str, result=str)
    def getData(self, index, role):
        d = self._data[index]
        return d[role]

    def data(self, index, role):
        d = self._data[index.row()]

        if role == Qt.DisplayRole:
            return d['name']
        elif role == Qt.DecorationRole:
            return Qt.black
        elif role == DecksModel.NameRole:
            return d['deckName']
        elif role == DecksModel.PathRole:
            return d['deckPath']
        elif role == DecksModel.FactCountRole:
            return d['deckFactCount']
        elif role == DecksModel.CardCountRole:
            return d['deckCardCount']
        return None

    @QtCore.Slot()
    def populate(self):
        path="/home/user/devel/decks"
        if not os.path.isdir(path):
            os.mkdir(path)
        dirList=os.listdir(path)
        deckHelper = DeckWrapper()
        del self._data[:]
        for fname in dirList:
            if fname.endswith(".anki"):
                deckPath = path+'/'+fname 
                deckHelper.openDeck(fname)  
                name = deckHelper.getDeckInfo("name")
                factCount = deckHelper.getDeckInfo("factCount")
                cardCount = deckHelper.getDeckInfo("cardCount")
                self._data.append({'name':fname, 'deckName': name, 'deckPath':deckPath, 'deckFactCount': factCount, 'deckCardCount': cardCount})
                deckHelper.closeDeck()
        self.reset()

class DeckWrapper(QtCore.QObject):

    def __init__(self, parent = None):
        QtCore.QObject.__init__(self, parent)
        self.opened = False
        self.finished = False

    def __del__(self, parent = None):
        self.stopSession()
        self.closeDeck()

    @QtCore.Slot(str)
    def openDeck(self, name):
        path = self._pathFromName(name)
        self.deck = anki.DeckStorage.Deck(path, backup=False)
        self.opened = True

    @QtCore.Slot()
    def closeDeck(self):
        if not self.opened:
            return
        self.deck.save()
        self.deck.s.flush()
        self.deck.close()
        self.opened = False

    @QtCore.Slot()
    def startSession(self):
        self.deck.startSession()
        
    @QtCore.Slot()
    def stopSession(self):
        if  not self.opened:
            return
        self.deck.stopSession()
        self.finished = False

    @QtCore.Slot()
    def getCard(self):
        if not self.opened:
            return
        self.card = self.deck.getCard()
        if not self.card:
            self.finished = True

    @QtCore.Slot(result=str)
    def getQuestion(self):
        if not self.opened:
            return ""
        return self.card.htmlQuestion()

    @QtCore.Slot(result=str)
    def getAnswer(self):
        if not self.opened:
            return ""
        return self.card.htmlAnswer()

    @QtCore.Slot(int)
    def answerCard(self, quality):
        if not self.opened:
            return
        self.deck.s.refresh(self.card)
        self.deck.s.refresh(self.card.fact)
        self.deck.s.refresh(self.card.cardModel)
        self.deck.s.expunge(self.card)

        self.deck.answerCard(self.card, quality)

    @QtCore.Slot(result=bool)
    def Finished(self):
        return self.finished

    @QtCore.Slot(result=str)
    def DeckFinishedMsg(self):
        if self.finished:
            return self.deck.deckFinishedMsg()

    @QtCore.Slot(str, result=str)
    def getDeckInfo(self, key):
        if self.opened == False:
            return ""
        self.deckInfo = {
            "name": self.deck.name(),
            "description": `self.deck.description`,
            "cardCount": `self.deck.cardCount`,
            "factCount": `self.deck.factCount`,
            "revCount": `self.deck.revCount`,
            "newCount": `self.deck.newCount`,
        }
        return self.deckInfo.get(key, "")

    @QtCore.Slot(result="QVariantList")
    def CurrentModelFields(self):
        fields = []
        model = self.deck.currentModel
        for fieldModel in model.fieldModels:
            fields.append(fieldModel.name)
        return fields

    def _updateFact(self, fact, map):
        for i in range(0, len(map.keys())):
            fact.__setitem__(map.keys()[i], map.values()[i])
        if self.deck.factIsInvalid(fact):
            return False
        return True

    @QtCore.Slot("QVariantMap", result=bool)
    def AddFact(self, map):
        if self.opened == False:
            return False

        fact = self.deck.newFact()
        self._updateFact(fact, map)
        self.deck.addFact(fact)
        self._reset()

        return True

    @QtCore.Slot(str, result=str)
    def getFactInfo(self, key):
        if self.opened == False:
            return ""
        self.factInfo = {
            "id": `self.card.fact.id`,
        }
        return self.factInfo.get(key, "")

    @QtCore.Slot(str, result=str)
    def getFactValue(self, key):
        if self.opened == False:
            return ""
        return self.card.fact.__getitem__(key)

    @QtCore.Slot("QVariantMap", result=bool)
    def EditFact(self, map):
        if self.opened == False:
            return False

        fact = self.card.fact
        self._updateFact(fact, map)
        fact.setModified(textChanged=True, deck=self.deck)
        self.deck.save()
        self.deck.s.refresh(fact)
        self._reset()

        return True

    def _reset(self):
        if self.opened == False:
            return False
        self.deck.refreshSession()
        self.deck.reset()

    @QtCore.Slot(result=bool)
    def deleteCurrentCard(self):
        if self.opened == False:
            return False
        self.deck.deleteCard(self.card.id)
        self._reset()
        return True

    @QtCore.Slot(str)
    def setMode(self, mode):
        if (mode == "cram"):
            self.deck.setupCramScheduler("", "random()")
        elif (mode == "learnMode"):
            self.deck.setupLearnMoreScheduler()
        elif (mode == "reviewEarly"):
            self.deck.setupReviewEarlyScheduler()

    @QtCore.Slot(str, result=bool)
    def addDeck(self, name):
        path = self._pathFromName(name)
        if (os.path.exists(path)):
            return False
        deck = anki.DeckStorage.Deck(path, backup=False)
        deck.addModel(BasicModel())
        deck.save()
        deck.close()
        return True

    def _pathFromName(self, name):
        path = "/home/user/devel/decks/" + name
        if not name.lower().endswith(".anki"):
            path += ".anki"
        return path

    @QtCore.Slot(str, result=str)
    def getCardInfo(self, key):
        if self.opened == False:
            return ""
        self.cardInfo = {
            "id": `self.card.id`,
            "successive": `self.card.successive`,
        }
        return self.cardInfo.get(key, "")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    view = QDeclarativeView()
    url = QUrl('/usr/share/ankiqml/qml/view.qml')

    decksModel = DecksModel()
    deck = DeckWrapper()

    ctx = view.rootContext()
    ctx.setContextProperty('Deck', deck)
    ctx.setContextProperty('decksModel', decksModel)

    view.setResizeMode(QDeclarativeView.SizeRootObjectToView)
    view.setSource(url)
    view.showFullScreen()
    sys.exit(app.exec_())
